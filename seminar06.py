# Семинар 6

# Задача №35. 
# Напишите функцию, которая принимает одно число и проверяет, является ли оно простым 
# Напоминание: Простое число - это число, которое имеет 2 делителя: 1  и n(само число) 
# Input: 5 Output: yes

# k = int(input("Введите число N: "))
# def simple(x, a = 2):
#     if x <= 1:
#         return False
#     if a * a > x:
#         return True
#     if x % a == 0:
#         return False
#     return simple(x, a + 1)
# if simple(k):
#     print("yes")
# else:
#     print("no")

# Задача №37. 
# Дано натуральное число N и последовательность из N элементов. 
# Требуется вывести эту последовательность в обратном порядке. 
# Примечание. В программе запрещается объявлять массивы и использовать циклы (даже для ввода и вывода). 
# Input:    2 -> 3 4 Output: 4 3

# Задача про палиндром
# Определить срока является палиндромом или нет

# def palindrom(n):
#     if len(n) <= 1:
#         return True
#     if n[0] == n[-1]:
#         return palindrom(n[1: -1]) # срез: 1-ой точкой является - старт, второй - та, точка до которой не доходит (len-1)
#     return False

# a = str(input("Введите строку: "))
# if palindrom(a) == True:
#     print ("Палиндром")
# else:
#     print ("Не палиндром")

# Задача №39. 
# Требуется вывести те элементы первого массива (в том порядке, в каком они идут в первом массиве), 
# которых нет во втором массиве. Пользователь вводит  число N - количество элементов в первом массиве, 
# затем N чисел - элементы массива. Затем число M - количество элементов во втором массиве. 
# Затем элементы второго 
# Ввод: 7 3 1 3 4 2 4 12 6 4 15 43 1 15 1 
# Вывод: 3 3 2 12 массива

# Задача №45. 
# Два различных натуральных числа n и m называются дружественными, если сумма делителей числа n 
# (включая 1, но исключая само n) равна числу m и наоборот. Например, 220 и 284 – дружественные числа. 
# По данному числу k выведите все пары дружественных чисел, каждое из которых не превосходит k. 
# Программа получает на вход одно натуральное число k, не превосходящее 105. 
# Программа должна вывести  все пары дружественных чисел, каждое из которых не превосходит k. 
# Пары необходимо выводить по одной в строке, разделяя пробелами. 
# Каждая пара должна быть выведена только один раз (перестановка чисел новую пару не дает). 
# Ввод: Вывод: 300 220 284

# Как решать: составить список из кортежей. 1 кортеж - (число от  1 до 300, сумма его делителей)
# реверс кортежа: если 1 элемент этого кортежа равен последнему второго кортежа, то тогда это просток число


# Задача 30:  
# Заполните массив элементами арифметической прогрессии. 
# Её первый элемент a1 , разность d и количество элементов n будет задано автоматически. 
# Формула для получения n-го члена прогрессии: an = a1 + (n-1) * d.

# арифм прогрессия

# a1 = 2
# d = 3
# n = 4
# arr = []
# for i in range(n):
#     an = a1 + (n - 1) * d
#     arr.append(an)
#     n = n - 1
# arr.reverse()
# print(*arr, sep = "\n") 

# Решение автотеста:
# for i in range(n):
#   print(a1 + i * d)


# Задача 32: 
# Определить индексы элементов массива (списка), значения которых принадлежат заданному диапазону 
# (т.е. не меньше заданного минимума и не больше заданного максимума).
# На вход подается список с элементами list_1 и границы диапазона в виде чисел 
# min_number, max_number.

# list_1 = [-5, 9, 0, 3, -1, -2, 1, 4, -2, 10, 2, 0, -9, 8, 10, -9, 0, -5, -5, 7]
# min_number = 0
# max_number = 10
# for i in range(len(list_1)):
#     if list_1[i] >= min_number and list_1[i] <= max_number:
#         print(i)
        
# решение астотеста:
# for i in range(len(list_1)):
#   if min_number <= list_1[i] <= max_number:
#     print(i)