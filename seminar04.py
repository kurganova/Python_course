# st = '1 2 3 4 5 6'
# print(st)
# print(type(st))
# print(st.split())
# print(st.split(' ')) # находит разделитель (то, что в ковычках), вытаскивает его и элементы разъеденяет и отправляет в список
# st = input().split()

# Задача №25. 
# Напишите программу, которая принимает на вход строку, и отслеживает, сколько раз каждый символ 
# уже встречался. Количество повторов добавляется к символам с помощью постфикса формата _n. 
# Input: a a a b c a a d c d d 
# Output: a a_1 a_2 b c a_3 a_4 d c_1 d_1 d_2 
# Для решения данной задачи используйте функцию .split()

# k = 'a a a b c a a d c d d'
# lst = k.split() # преобразуем строку в список
# res = {} # создаем пустой словарь
# for i in lst:
#     if i not in res:
#         print(i, end = ' ')
#         # res[i] = 1
#     else:
#         print(f"{i}_{res[i]}", end = ' ')
#         # res[i] += 1
#     res[i] = res.get(i, 0) + 1 # метод get заменяет 21 и 24 строки

# Задача №27. 
# Пользователь вводит текст(строка). Словом считается последовательность непробельных символов 
# идущих подряд, слова разделены одним или большим числом пробелов. Определите, сколько различных 
# слов содержится в этом тексте. 
# Input: She sells sea shells on the sea shore The shells that she sells are sea shells I'm sure.
# So if she sells sea shells on the sea shore I'm sure that the shells are sea shore shells 
# Output: 13


# Домашнее задание

# Задача 22: 
# Даны два неупорядоченных набора целых чисел (может быть, с повторениями). 
# Выдать без повторений в порядке возрастания все те числа, которые встречаются в обоих наборах.
# На вход подается 2 числа через пробел: n m
# n - кол-во элементов первого множества.
# m - кол-во элементов второго множества.
# Затем подаются элементы каждого множества через пробел в виде строки. 
# ! Писать input() не надо
# Пример
# На входе:
# var1 = '5 4' # количество элементов первого и второго множества
# var2 = '1 3 5 7 9' # элементы первого множества через пробел
# var3 = '2 3 4 5' # элементы второго множества через пробел
# На выходе:
# 3 5

# Решение:
# var1 = '5 4' 
# var2 = '1 8 3 5 7 9' 
# var3 = '2 8 3 4 5'

# set_a = set(var2.split())
# set_b = set(var3.split())
# set_c = set_a.intersection(set_b)
# # print(set_c)
# lst = list(set_c)
# lst_int = [int(x) for x in lst]
# lst_result = lst_int.sort()
# # print(lst, lst_int, lst_result)
# st_result = ' '.join(str(i) for i in lst_int)
# print(st_result)

# решение автотеста:
# mol = [int(x) for x in var1.split()]
# n = mol[0]
# m = mol[1]
# set_1 = set()
# set_2 = set()
# list_1 = list()
# a = [int(x) for x in var2.split()]
# k = set(a)
# for i in k:
#    set_1.add(i)
# b = [int(x) for x in var3.split()]
# k1 = set(b)
# for i in k1:
#    set_2.add(i)
# lok = set_1 & set_2
# kool = list(lok)
# kool.sort()
# for i in kool:
#    print(i, end=' ')

  
# Задача 24: 
# В фермерском хозяйстве в Карелии выращивают чернику. Черника растет на круглой грядке, 
# и кусты черники высажены по окружности грядки. Каждый куст черники имеет урожайность, которая 
# соответствует количеству ягод на этом кусте.Урожайность черничных кустов представлена в виде 
# списка arr, где arr[i] - это урожайность (количество ягод) i-го куста.
# В фермерском хозяйстве внедрена система автоматического сбора черники. 
# Эта система состоит из управляющего модуля и нескольких собирающих модулей. 
# Каждый собирающий модуль может собрать ягоды с одного куста и с двух соседних кустов. 
# Собирающий модуль находится перед определенным кустом, и он может выбирать, с какого куста 
# начать сбор ягод.
# Ваша задача - написать программу, которая определит максимальное число ягод, которое может 
# собрать один собирающий модуль за один заход, находясь перед некоторым кустом грядки.
# Входные данные:
# На вход программе подается список arr, где arr[i] (1 ≤ arr[i] ≤ 1000) - урожайность i-го куста 
# черники. Размер списка не превышает 1000 элементов.
# Выходные данные:
# Программа должна вывести одно целое число - максимальное количество ягод, которое может 
# собрать собирающий модуль, находясь перед некоторым кустом грядки.

# Решение:
arr = [2, 4, 10, 4, 2]
n = len(arr)
max_berries = 0
i = 0
for i in range(n):
    if arr[i] == arr[0]:
        sum_berries = arr[0] + arr[1] + arr[n - 1]
    elif arr[i] == arr[n - 1]:
        sum_berries = arr[i] + arr[0] + arr[n - 2]
    else:
        sum_berries = arr[i] + arr[i + 1] + arr[i - 1]
    if sum_berries >= max_berries:
        max_berries = sum_berries
    i = i + 1
print(max_berries)

# решение автотеста:
# arr_count = list()
# for i in range(len(arr) - 1):
#     arr_count.append(arr[i - 1] + arr[i] + arr[i + 1])
# arr_count.append(arr[-2] + arr[-1] + arr[0])

# # Вывод максимальной урожайности, которую может собрать собирающий модуль
# print(max(arr_count))
