# Семинар 07

# def f(a):
#     return a
# print(f(6))
# f1 = lambda a: a
# print(f1(7))
# print((lambda a: a)(7))

# lst = "8 9 3 4 6 7 0".split()
# print(lst)
# lst1 = list(map(int, lst)) # переводит str в int
# print(lst1)
# lst2 = list(map(lambda a: a * 2, lst1)) # map перебирает элементы списка и меняет их
# print(lst2)

# lst3 = list(filter(lambda a: a % 2, lst1)) #filter делает преобразования и отвечает на вопрос True или False (число нечетное? всё, что делится на 2, дает 0, а 0 вопринимается машиной как False)
# print(lst3)

# Задача №47. 
# У вас есть код, который вы не можете менять (так часто бывает, когда код в глубине программы 
# используется множество раз и вы не хотите ничего сломать): 
# transformation = <???> values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] 
# # или любой другой список transormed_values = list(map(transformation, values)) 
# Единственный способ вашего взаимодействия с этим кодом - посредством задания функции transformation. 
# Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать список значений, 
# а нужно получить его как есть. Напишите такое лямбда-выражение transformation, чтобы 
# transformed_values получился копией values. 
# Пример ввода и вывода данных:
# Ввод: values = [1, 23, 42, ‘asdfg’] 
# transformed_values = list(map(trasformation, values)) 
# if values == transformed_values:    
#     print(‘ok’) 
# else:    print(‘fail’) 
# Вывод: ok

# Решение:
# values = [1, 23, 42, 'asdfg'] 

# transformed_values = list(map(lambda a: a, values)) # копируем элемент из 1 списка в другой с помощью lambda
# if values == transformed_values:    
#     print('ok') 
# else:    print('fail')



# Задача №49. 
# Планеты вращаются вокруг звезд по эллиптическим орбитам. Назовем самой далекой планетой ту, 
# орбита которой имеет самую большую площадь. Напишите функцию find_farthest_orbit(list_of_orbits), 
# которая среди списка орбит планет найдет ту, по которой вращается самая далекая планета. 
# Круговые орбиты не учитывайте: вы знаете, что у вашей звезды таких планет нет, 
# зато искусственные спутники были были запущены на круговые орбиты. 
# Результатом функции должен быть кортеж, содержащий длины полуосей эллипса орбиты самой 
# далекой планеты. Каждая орбита представляет из себя кортеж из пары чисел - полуосей ее эллипса. 
# Площадь эллипса вычисляется по формуле S = pi*a*b, где a и b - длины полуосей эллипса. 
# При решении задачи используйте списочные выражения. 
# Подсказка: проще всего будет найти эллипс в два шага: сначала вычислить самую большую площадь эллипса,
# а затем найти и сам эллипс, имеющий такую  площадь. Гарантируется, что самая далекая планета ровно 
# одна 
# Пример ввода и вывода данных:
# Ввод: 
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)] 
# print(*find_farthest_orbit(orbits)) 
# Вывод: 2.5 10

# Решение 1:
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)] 
# def find_farthest_orbit(list_of_orbits):
#     lst1 = list(filter(lambda a: a[0] != a[1], list_of_orbits))
#     lst2 = list(map(lambda b: b[0] * b[1], lst1))
#     max = lst2[0]
#     index = 0
#     for item in range(len(lst2)):
#         if lst2[item] > max:
#             max = lst2[item]
#             index = item
#         return lst1[index]
# print(*find_farthest_orbit(orbits))

# Решение 2:
# from math import pi
# def find_farthest_orbit(orbit):
#     elipse_area = lambda a, b: PI*a*b
#     max_elipse = max(map(lambda o: elipse_area(*o), orbit))
    
#     for o in orbit:
#         if elipse_area(*o) == max_elipse:
#             yield o # yield можно заменить на return
            
# PI = pi
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)] 
# orbit1 = [(a, b) for a, b in orbits if a != b]
# print(*find_farthest_orbit(orbit1))

# Решение 3 (От препода):
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)] 
# print(max(orbits, key=lambda x: x[0]*x[1]*(x[0]!=x[1])))

# Домашнее задание
# Задача №51. 
# Напишите функцию same_by(characteristic, objects), которая проверяет, все ли объекты имеют 
# одинаковое значение некоторой характеристики, и возвращают True, если это так. 
# Если значение характеристики для разных объектов отличается - то False. 
# Для пустого набора объектов, функция должна возвращать True. 
# Аргумент characteristic - это функция, которая принимает объект и вычисляет его характеристику.

# Задача 34: 
# Винни-Пух попросил Вас посмотреть, есть ли в его стихах ритм. Поскольку разобраться в его 
# кричалках не настолько просто, насколько легко он их придумывает, Вам стоит написать программу. 
# Винни-Пух считает, что ритм есть, если число слогов (т.е. число гласных букв) в каждой фразе 
# стихотворения одинаковое. Фраза может состоять из одного слова, если во фразе несколько слов, 
# то они разделяются дефисами. Фразы отделяются друг от друга пробелами. Стихотворение  Винни-Пух 
# вбивает в программу с клавиатуры. В ответе напишите “Парам пам-пам”, если с ритмом все в порядке 
# и “Пам парам”, если с ритмом все не в порядке

# lambda или фильтрация, сплит, создаете пустой список и записываете туда элемент "кол-во гласных букв"
# если все элементы списка (все циыры) равны, значит в каждой строчке одинаковое кол-во букв. 
# выводите парам-пам-пам, если где-то не равны, то пам парам. как найти? 1 способ:
# сравнивать результат функций max и min

# stroka = 'пух'
# lst = list(stroka.split())
# # print(lst)
# lst_volwes = []
# for item in lst:
#     n = 0
#     for letter in item:
#         if letter in 'аяоёуюэеыи':
#             n += 1
#     lst_volwes.append(n)
# # print(lst_volwes)
# if len(lst_volwes) == 1:
#     print("Количество фраз должно быть больше одной!")
# elif max(lst_volwes) == min(lst_volwes):
#     print("Парам пам-пам")
# else:
#     print("Пам парам")
    
# решение автотеста:
# vowels = ['а', 'е', 'ё', 'и', 'й', 'о', 'у', 'ы', 'э', 'ю', 'я']
# phrases = stroka.split()
# if len(phrases) < 2:
#  print('Количество фраз должно быть больше одной!')
# else:
#  countVowels = []

#  for i in phrases:
#   countVowels.append(len([x for x in i if x.lower() in vowels]))

#  if countVowels.count(countVowels[0]) == len(countVowels):
#   print('Парам пам-пам')
#  else:
#   print('Пам парам')

# решение ученика на разборе дз:
# poem = 'в-го-ло-ве мо-ей о-пил-ки'.split()
# vowels = 'аяоёуюэеыи'
# poem_vowels = list(map(lambda x: sum(x.count(i) for i in vowels), poem))
# print(poem_vowels)
# if len(poem_vowels) == 1:
#     print("Количество фраз должно быть больше одной!")
# # elif max(poem_vowels) == min(poem_vowels): # или вместо нее строка ниже:
# if len(poem_vowels) == poem_vowels.count(poem_vowels[0]):
#     print("Парам пам-пам")
# else:
#     print("Пам парам")
    
# Задача 36:  
# Напишите функцию print_operation_table(operation, num_rows=6, num_columns=6), 
# которая принимает в качестве аргумента функцию, вычисляющую элемент по номеру строки и столбца. 
# Аргументы num_rows и num_columns указывают число строк и столбцов таблицы, которые должны быть 
# распечатаны. Нумерация строк и столбцов идет с единицы (подумайте, почему не с нуля). 
# Примечание: бинарной операцией называется любая операция, у которой ровно два аргумента, 
# как, например, у операции умножения.

# для принта испоользовать end - каждую итерацию печатать в ряд. в автотест вместо 6 поставить 9

# def print_operation_table(operation, num_rows, num_columns):
#     if num_rows < 2:
#         print("ОШИБКА! Размерности таблицы должны быть больше 2!")
#         return
#     itog = [[operation(row, col) for row in range(1, num_columns + 1)] for col in range(1, num_rows + 1)]
#     for i in itog:
#         print(*[f"{x}" for x in i])


# print_operation_table(lambda x, y: x * y, 9, 9)

